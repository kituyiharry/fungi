(* Generated by `dune ocaml top` *)
(*#load "./_build/default/libparity.cma";;*)
(*#use_output "dune ocaml top";;*)
#load "/Users/harrykwakuloba/Developer/Ocaml/libparity/ocaml/_build/default/src/fungi.cma";;
#directory "_build/default/src";;
#directory "_build/default/examples/paritygame/.main.eobjs/byte";;

open Fungi;;
open Paritygame.Game;;
open Paritygame.Utils;;
open Treeset;;
(*open Utils;;*)

(*open ParityGame.Graph.Scc;;*)
(*open ParityGame.Graph.Cluster;;*)

let p = ParityGame.empty;;

(* <> is Odd, () is Even *)

(* I also assume there are no same priority nodes to make life easy *)
let (l_2, p)  = ParityGame.add_node  ParityGame.Even 2  p;;
let (l_15,p)  = ParityGame.add_node  ParityGame.Odd  15 p;;
let (l_4, p)  = ParityGame.add_node  ParityGame.Even 4  p;;
let (l_6, p)  = ParityGame.add_node  ParityGame.Even 6  p;;
let (l_8, p)  = ParityGame.add_node  ParityGame.Even 8  p;;
let (l_10,p)  = ParityGame.add_node  ParityGame.Even 10 p;;
let (l_3, p)  = ParityGame.add_node  ParityGame.Odd  3  p;;
let (l_5, p)  = ParityGame.add_node  ParityGame.Odd  5  p;;
let (l_7, p)  = ParityGame.add_node  ParityGame.Odd  7  p;;
let (l_9, p)  = ParityGame.add_node  ParityGame.Odd  9  p;;
let (l_11,p)  = ParityGame.add_node  ParityGame.Odd  11 p;;
let (l_13,p)  = ParityGame.add_node  ParityGame.Odd  13 p;;
let (l_99,p)  = ParityGame.add_node  ParityGame.Odd  99 p;;

(** Effect of opposer-controlled but supportive priority *)

(*let (l_16,p)  = ParityGame.add_node  ParityGame.Odd  16 p;;*)
(*let (l_31,p)  = ParityGame.add_node  ParityGame.Even 31 p;;*)

(** Effect of  Disjointness  - Graph not being fully connected *)

(*let (l_99,p)  = ParityGame.add_node  ParityGame.Odd  9 p;;*)

(**
  A non-empty Parity game will always have a Even labeled node 2 or
  an Odd labeled node 3
**)

(**
parity 15;
2  2 0 4, 11 "2";
4  4 0 2, 8, 6 "4";
6  6 0 3, 5, 7, 9 "6";
8  8 0 7, 5, 2 "8";
10 10 0 13, 15 "10";
3  3 1 2, 4 "3";
5  5 1 5, 7, 9 "5";
7  7 1 10, 7 "7";
9  9 1 3, 10, 5 "9";
11 11 1 8 "11";
13 13 1 15 "13";
15 15 1 13 "15";

-- Ommited for testing other stuff
16 16 1 2,31 "16";
31 31 0 15,16 "31";
99 99 1 99 "99";

 *)

let p_adjlist =
  [
    (l_2,  [l_4;  l_11]);
    (l_4,  [l_2;  l_8;  l_6]);
    (l_6,  [l_3;  l_5;  l_7; l_9]);
    (l_8,  [l_7;  l_5;  l_2]);
    (l_10, [l_13; l_15]);
    (l_3,  [l_2;  l_4]);
    (l_5,  [l_7;  l_9]);
    (l_7,  [l_10]);
    (l_9,  [l_3;  l_5;  l_10;]);
    (l_11, [l_8]);
    (l_13, [l_15]);
    (l_15, [l_13])
]

let p = ParityGame.Graph.of_list p_adjlist p;;

let t = ParityGame.empty;;

let (t_1, t)  = ParityGame.add_node  ParityGame.Even 1  t;;
let (t_2, t)  = ParityGame.add_node  ParityGame.Odd  2  t;;
let (t_3, t)  = ParityGame.add_node  ParityGame.Even 3  t;;
let (t_4, t)  = ParityGame.add_node  ParityGame.Even 4  t;;
let (t_5, t)  = ParityGame.add_node  ParityGame.Even 5  t;;
let (t_6, t)  = ParityGame.add_node  ParityGame.Even 6 t;;
let (t_7, t)  = ParityGame.add_node  ParityGame.Odd  7  t;;
let (t_8, t)  = ParityGame.add_node  ParityGame.Odd  8  t;;

let t_adjlist =
  [
    (t_1,  [t_2;t_3]);
    (t_2,  [t_1;t_4]);
    (t_3,  [t_4;]);
    (t_4,  [t_5;t_6]);
    (t_5,  [t_6;t_3;t_7]);
    (t_6,  [t_8]);
    (t_7,  [t_6]);
    (t_8,  [t_7]);
]

let t = ParityGame.Graph.of_list t_adjlist t;;

(** Effect of opposer-controlled but supportive priority *)

(*let p = ParityGame.Graph.add_edge l_16 l_2   p;;*)
(*let p = ParityGame.Graph.add_edge l_2 l_16   p;;*)
(*let p = ParityGame.Graph.add_edge l_15 l_31  p;;*)
(*let p = ParityGame.Graph.add_edge l_31 l_15  p;;*)
(*let p = ParityGame.Graph.add_edge l_31 l_16  p;;*)
(*let p = ParityGame.Graph.add_edge l_16 l_31  p;;*)

(** Leading into the highest value of the opposition *)
(*let p = ParityGame.add_edge l_11 l_31  p;;*)

(** Effect of  Disjointness *)

(*let p = ParityGame.add_edge l_99 l_99  p;;*)

(**

parity 10;
0 6 0 2,3,5 "0";
1 10 0 3,4,8 "1";
2 6 1 0,5,7 "2";
3 2 0 0,3,9 "3";
4 7 0 2,5,7 "4";
5 0 0 0,4,8 "5";
6 7 0 0,5,8 "6";
7 9 0 1,3,9 "7";
8 9 0 4,6,9 "8";
9 2 0 2,4,8 "9";

 *)

let q =  ParityGame.empty

let (q_0, q)  = ParityGame.add_node   ParityGame.Even 6  q;;
let (q_1, q)  = ParityGame.add_node   ParityGame.Even 10 q;;
let (q_2, q)  = ParityGame.add_node   ParityGame.Odd  6  q;;
let (q_3, q)  = ParityGame.add_node   ParityGame.Even 2  q;;
let (q_4, q)  = ParityGame.add_node   ParityGame.Even 7  q;;
let (q_5, q)  = ParityGame.add_node   ParityGame.Even 0  q;;
let (q_6, q)  = ParityGame.add_node   ParityGame.Even 7  q;;
let (q_7, q)  = ParityGame.add_node   ParityGame.Even 9  q;;
let (q_8, q)  = ParityGame.add_node   ParityGame.Even 9  q;;
let (q_9, q)  = ParityGame.add_node   ParityGame.Even 2  q;;

let q_adjlist =
  [
    (q_0, [q_2; q_3; q_5;]);
    (q_1, [q_3; q_4; q_8;]);
    (q_2, [q_0; q_5; q_7;]);
    (q_3, [q_0; q_3; q_9;]);
    (q_4, [q_2; q_5; q_7;]);
    (q_5, [q_0; q_4; q_8;]);
    (q_6, [q_0; q_5; q_8;]);
    (q_7, [q_1; q_3; q_9;]);
    (q_8, [q_4; q_6; q_9;]);
    (q_9, [q_2; q_4; q_8;])
  ]

let q = ParityGame.Graph.of_list q_adjlist q;;

let r = ParityGame.empty

let (r_100, r)  = ParityGame.add_node ParityGame.Even 100 r;;
let (r_5, r)    = ParityGame.add_node ParityGame.Even 5   r;;
let (r_1, r)    = ParityGame.add_node ParityGame.Even 1   r;;
let (r_0, r)    = ParityGame.add_node ParityGame.Even 0   r;;
let (r_0_b, r)  = ParityGame.add_node ParityGame.Even 0   r;;
let (r_0_c, r)  = ParityGame.add_node ParityGame.Even 0   r;;

let r_adjlist =
  [
    (r_1,   [r_0;]);
    (r_0,   [r_5;]);
    (r_5,   [r_0_b;]);
    (r_0_b, [r_1;]);
    (r_100, [r_0_b; r_0_c]);
    (r_0_c, [r_0_c]);
  ]

let r = ParityGame.Graph.of_list r_adjlist r;;

let x = ParityGame.empty

let (x_1, x)  = ParityGame.add_node ParityGame.Even 1 x;;
let (x_2, x)  = ParityGame.add_node ParityGame.Even 0 x;;
let (x_3, x)  = ParityGame.add_node ParityGame.Even 0 x;;
let (x_4, x)  = ParityGame.add_node ParityGame.Even 0 x;;

let x_adjlist =
  [
    (x_1,   [x_2;]);
    (x_2,   [x_3;]);
    (x_3,   [x_4;]);
  ]

let x = ParityGame.Graph.of_list x_adjlist x;;

let c = ParityGame.empty;;

let (c_1, c)  = ParityGame.add_node  ParityGame.Odd  1  c;;
let (c_2, c)  = ParityGame.add_node  ParityGame.Even 2  c;;
let (c_3, c)  = ParityGame.add_node  ParityGame.Odd  3  c;;
let (c_4, c)  = ParityGame.add_node  ParityGame.Even 4  c;;
let (c_5, c)  = ParityGame.add_node  ParityGame.Odd  5  c;;
let (c_6, c)  = ParityGame.add_node  ParityGame.Even 6  c;;
let (c_8, c)  = ParityGame.add_node  ParityGame.Even 8  c;;

let c_adjlist =
  [
    (c_1,  [c_2;c_5]);
    (c_2,  [c_1;c_3;c_5]);
    (c_3,  [c_2;c_4;]);
    (c_4,  [c_3;c_6;c_5]);
    (c_5,  [c_4;c_2;c_1]);
    (c_6,  [c_4]);
    (c_8,  [c_8]);
]

let c = ParityGame.Graph.of_list c_adjlist c;;

(* dag *)
let d = ParityGame.empty;;

let (d_0, d)  = ParityGame.add_node  ParityGame.Odd  0  d;;
let (d_1, d)  = ParityGame.add_node  ParityGame.Odd  1  d;;
let (d_2, d)  = ParityGame.add_node  ParityGame.Even 2  d;;
let (d_3, d)  = ParityGame.add_node  ParityGame.Odd  3  d;;
let (d_4, d)  = ParityGame.add_node  ParityGame.Even 4  d;;
let (d_5, d)  = ParityGame.add_node  ParityGame.Odd  5  d;;
let (d_6, d)  = ParityGame.add_node  ParityGame.Even 6  d;;
let (d_7, d)  = ParityGame.add_node  ParityGame.Even 7  d;;

let d_adjlist =
    [
        (d_0,  [d_6]);
        (d_1,  [d_6;d_2;d_4]);
        (d_2,  []);
        (d_3,  [d_4;d_0]);
        (d_4,  []);
        (d_5,  [d_1;]);
        (d_6,  []);
        (d_7,  [d_0; d_1]);
    ]

let d = ParityGame.Graph.of_list d_adjlist d;;

(* Convenience functions for printing in the REPl *)
(** [asplayerprio ParityGame.t (node * priority)]
helper to show parity game as a graph without the random generated ids *)
let asplayerprio (ParityGame.Label (ParityGame.Priority (value, player) as prio , _rand)) =
    (player, prio)
;;

let print_player_prio (ParityGame.Label(ParityGame.Priority (value,pplayer),_))  = match pplayer with
| ParityGame.Even -> Format.printf " (%02d) " value
| ParityGame.Odd  -> Format.printf " <%02d> " value
;;

let print_player_prio_dir (_, (ParityGame.Priority (value,pplayer)))  = match pplayer with
| ParityGame.Even -> Format.printf " (%02d) " value
| ParityGame.Odd  -> Format.printf " <%02d> " value
;;

type adj = ParityGame.node ParityGame.AdjSet.set;;
type edg = ParityGame.play ParityGame.StrSet.set;;
type weights = unit   ParityGame.Graph.Weights.t;;

let pp_parity_game:(adj * adj * ParityGame.node * weights) ParityGame.Nodes.t -> unit = fun game ->
  Format.printf "G: {";
   List.iter (print_player_prio)
   (
    ParityGame.bindings game
   );
  Format.printf "} "
;;

let pp_adjset_depth (set: adj) =
  Format.printf "{$: {";
  if ParityGame.AdjSet.is_empty set then
    Format.printf " ∅ "
      else
  List.iter (print_player_prio_dir)
  (
    List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
  );
    Format.printf "} $} "
;;

let pp_adjset set =
  Format.printf "{$: {";
  if ParityGame.AdjSet.is_empty set then
  Format.printf " ∅ "
      else
  List.iter (print_player_prio_dir)
  (
    List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
  );
    Format.printf "} $} "
;;

let terseness = 30

let pp_parity_game_terse:(adj * adj * ParityGame.node * weights) ParityGame.Nodes.t -> unit =
  fun game ->
  let card = ParityGame.Nodes.cardinal game in
  if  card <= terseness then
    pp_parity_game game
  else
    (Format.printf "G: {";
    List.iter (print_player_prio)
    (
      Utils.take terseness
      @@ ParityGame.bindings game
    );
    Format.printf " ... } ")
;;

let pp_adjset_terse set =
  let card = ParityGame.AdjSet.cardinal set in
  if  card <= terseness then
    pp_adjset set
  else
    let _ = Format.printf "A: {" in
    if ParityGame.AdjSet.is_empty set then
      Format.printf " ∅ "
    else
      let _ = List.iter (print_player_prio_dir)
    (
      (*only take 5 elements for display!*)
      Utils.take terseness @@ List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
    ) in Format.printf " ... } "
;;

let pp_prio (ParityGame.Priority (value, pplayer)) = match pplayer with
  | ParityGame.Even -> Format.printf " (%02d) " value
  | ParityGame.Odd  -> Format.printf " <%02d> " value
;;

let pp_node (ParityGame.Label (prio, rand )) =
    let () =    Format.printf "%03d:" rand in
        pp_prio prio
;;

let pp_player_adjlist: (ParityGame.node * ParityGame.node list) -> unit =
  fun  (n, a)->
    let () = pp_node n in
    let () = Format.printf "\t-> [" in
    let () = List.iter (pp_node) a in
    Format.printf "]\n"
;;


let pp_parity_game_adjacency:(adj * adj * ParityGame.node * weights) ParityGame.Nodes.t -> unit
= fun game ->
  Format.printf "{\n";
   List.iter (pp_player_adjlist)
   (
     List.map (fun node -> (node, ParityGame.Graph.adj_list_of node game))
     @@ ParityGame.bindings game
   );
  Format.printf "} "
;;

let pp_adjset_prefix set prefix =
  Format.printf "%s: {" prefix;
  if ParityGame.AdjSet.is_empty set then
  Format.printf " ∅ "
      else
  List.iter (print_player_prio_dir)
  (
    List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
  );
  Format.printf "} "
;;

let pp_player_inc_out: (ParityGame.node * adj * adj) -> unit =
  fun  (n, i, o)->
    let () = Format.printf "    " in
    let () = pp_node n in
    let () = Format.printf "--> [" in
    let () = pp_adjset_prefix i "In" in
    let () = pp_adjset_prefix o "Out" in
    Format.printf "]\n"
;;

let pp_parity_game_redundant:(adj * adj * ParityGame.node * weights) ParityGame.Nodes.t -> unit
= fun game ->
  Format.printf "{\n";
   List.iter (pp_player_inc_out)
   (
     List.map (fun (node) -> (node, ParityGame.Graph.incomingof node game,
                ParityGame.Graph.outgoingof node game ))
     @@ ParityGame.bindings game
   );
  Format.printf "} "
;;

let ppluck fromset =
  match ParityGame.StrSet.max_elt_opt fromset with
  | Some(node) -> Some (node, (ParityGame.StrSet.remove node fromset))
  | _ -> None
;;

let rec pp_strat: edg -> unit = fun strat ->
  if ParityGame.StrSet.is_empty strat then
    Format.printf " ∅ "
  else
    match ppluck strat with
    | None -> ()
    | Some(((f, t), rest)) -> (
      pp_node f; Format.printf " -> "; pp_node t; Format.printf ",";
      pp_strat rest
    );
;;

let pp_solution:(ParityGame.solution) -> unit = fun sol ->
 let ((w0, w1), (s0, s1)) = (sol.regions, sol.strategy) in
  Format.printf "\n\t+ ---  ---  --- --- --- --- --- --- --- --- --- --- ---";
  Format.printf "\n\t|\n\t| W0: ";  pp_adjset w0;
  Format.printf "\n\t| S0:    <";  pp_strat s0; Format.printf ">";
  Format.printf "\n\t|\n\t| ---  ---  --- --- --- --- --- --- --- --- --- --- ---";
  Format.printf "\n\t|\n\t| W1: ";  pp_adjset w1;
  Format.printf "\n\t| S1:    <";  pp_strat s1; Format.printf ">";
  Format.printf "\n\t|\n\t+ ---  ---  --- --- --- --- --- --- --- --- --- --- ---"
;;

let visitor eq x y = let _ = Format.printf "Visit " in let _ = pp_node x in
    let _ = Format.printf "\t" in let _ = pp_adjset_depth y in let _ =
        Format.printf "\n" in ParityGame.Graph.equal eq x
;;

let tables g =   
    ParityGame.Graph.Scc.SccTbl.iter (fun {link=link;node=x} y -> 
        let _ = Format.printf "lowlink: %03d\t" link in
        let _ = Format.printf ">-> node value: " in
        let _ = pp_node y in
        Format.printf "\n"
    ) g
;;

let sccsets g =   
    ParityGame.Graph.Scc.SccSet.iter (fun {link=link;node=x} -> 
        let _ = Format.printf "lowlink: %03d\t" link in
        let _ = Format.printf ">-> node value: " in
        let _ = pp_node x in
        Format.printf "\n"
    ) g
;;

let sccgraphs g  =   
    ParityGame.Graph.Scc.SccMap.iter (fun index (out, elts) -> 
        let _ = Format.printf "+------------------------------------- Scc Low Link: %03d -------------------------------------+\n"  index in
        let _ = List.iter (fun x -> Format.printf " %d " x) out in
        let _ = Format.printf "\n|                                                                                             |\n"  in
        let _ = pp_parity_game_redundant elts in
        let _ = Format.printf "\n|                                                                                             |\n"  in
        let _ = Format.printf "+---------------------------------------------------------------------------------------------+\n"  in
        Format.printf "\n"
    ) g
;;


let tarjanscc g = (ParityGame.Graph.Scc.subgraphs g (ParityGame.Graph.Scc.tarjan g).sccs)
;;

let kosarajuscc g = (ParityGame.Graph.Scc.subgraphs g (ParityGame.Graph.Scc.kosaraju g).sccs)
;;

(*a test ame with known edge cases *)
let g = Utils.smakerandomgame 42 15 6 4;;
let g2 = Utils.smakerandomgame 42 20 6 4;;

let pp_scc (sccnode: ParityGame.Graph.Scc.sccnode) =
    let _ = Format.printf "\n (~ %d) -> [" sccnode.link in
    let _ = pp_node sccnode.node in
    Format.printf "] | Index: %d" sccnode.indx
;;

let pp_sccset set =
  Format.printf "{$ SCC: {";
  if ParityGame.Graph.Scc.SccSet.is_empty set then
  Format.printf " ∅ "
      else
  ParityGame.Graph.Scc.SccSet.iter (pp_scc) (set);
    Format.printf "} $}\n "
;;

(* show full backtrace *)
let _ = Printexc.record_backtrace true;;

#install_printer pp_parity_game;;
#install_printer pp_parity_game_redundant;;
#install_printer pp_adjset;;
#install_printer pp_prio;;
#install_printer pp_node;;
#install_printer pp_strat;;
#install_printer pp_solution;;
#install_printer pp_adjset_depth;;
#install_printer tables;;
#install_printer sccsets;;
#install_printer sccgraphs;;
#install_printer pp_scc;;
#install_printer pp_sccset;;

(*#trace ParityGame.zielonka;;*)
(*#trace ParityGame.attr;;*)
(*#trace ParityGame.attractor;;*)
(*#trace ParityGame.attract;;*)
(*#trace ParityGame.attractive;;*)
(*#trace ParityGame.cluster;;*)
(*#trace ParityGame.pluck;;*)
(*#trace ParityGame.incomingof;;*)
(*#trace ParityGame.outgoingof;;*)
(*#trace ParityGame.carve;;*)
(*#trace ParityGame.AdjSet.remove;;*)
(*#trace ParityGame.AdjSet.diff;;*)
(*#trace ParityGame.AdjSet.filter;;*)
(*#trace ParityGame.AdjSet.fold;;*)
(*#trace ParityGame.Graph.NodeMap.update;;*)
(*#trace ParityGame.AdjSet.subset;;*)
(*#trace ParityGame.stack;;*)
(*#trace ParityGame.StrSet.of_list;;*)
(*#trace ParityGame.cmpplays;;*)
(*#trace ParityGame.Graph.Scc.SccSet.find_first_opt ;;*)
