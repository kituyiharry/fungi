#load "../../_build/default/examples/mazesolver/lib/mazesolver.cma";;
#load "../../_build/default/src/fungi.cma";;

open Fungi;;

module SGraph = Graph.MakeGraph(struct 
    type t     = string
    type edge  = float
    let compare= String.compare
end);;

module SGraph2 = Graph.MakeGraph(struct 
    type t     = string
    type edge  = unit
    let compare= String.compare
end);;
module SGraph4 = Graph.MakeGraph(Graph.Plain(String));;

let s  = SGraph.empty;;
let s' = SGraph.empty;;
let t  = SGraph.empty;;
let t' = SGraph.empty;;
let q  = SGraph.empty;;
let q' = SGraph.empty;;
let v  = SGraph.empty;;
let n  = SGraph.empty;;
let g  = SGraph.empty;;
let g2 = SGraph.empty;;
let fl = SGraph.empty;;
let scc = SGraph.empty;;

let s_a = "A";;
let s_b = "B";;
let s_c = "C";;
let s_d = "D";;
let s_e = "E";;
let s_f = "F";;
let s_g = "G";;
let s_h = "H";;
let s_i = "I";;
let s_j = "J";;
let s_k = "K";;
let s_l = "L";;
let s_s = "S";;

let n_0 = "0";;
let n_1 = "1";;
let n_2 = "2";;
let n_3 = "3";;
let n_4 = "4";;
let n_5 = "5";;
let n_6 = "6";;
let n_7 = "7";;
let n_8 = "8";;
let n_9 = "9";;

let nodes  = [ s_a; s_b; s_c; s_d; s_e; s_f; s_g; s_h; s_i; s_j; s_k; s_l; s_s ];;
let nodes' = [ s_a; s_b; s_c; s_d; s_e; s_f; ];;
let nuns   = [ n_0; n_1; n_2; n_3; n_4; (*n_5;*) n_6; n_7; n_8; n_9; ];;
let nuns2  = [ n_1; n_2; n_3; n_4; n_5; n_6; n_7; n_8; ];;
let n3     = [ n_1; n_2; n_3; n_4; ];;

let s  = List.fold_right (SGraph.add) nodes  s;;
let s' = List.fold_right (SGraph.add) nodes  s';;
let t  = List.fold_right (SGraph.add) nodes' t;;
let t' = List.fold_right (SGraph.add) nodes' t';;
let q  = List.fold_right (SGraph.add) nodes' q;;
let q' = List.fold_right (SGraph.add) nodes' q';;
let v  = List.fold_right (SGraph.add) nodes' v;;
let n  = List.fold_right (SGraph.add) nuns   n;;
let g  = List.fold_right (SGraph.add) nodes' g;;
let g2 = List.fold_right (SGraph.add) nodes' g2;;
let g2 = List.fold_right (SGraph.add) nodes' g2;;
let fl = List.fold_right (SGraph.add) n3     fl;;
let scc= List.fold_right (SGraph.add) nuns2  scc;;

let _ = Printexc.record_backtrace true;;

(* scc *)
let scc_adjlist =
  [
    (n_1,  [n_2;n_3]);
    (n_2,  [n_1;n_4]);
    (n_3,  [n_4;]);
    (n_4,  [n_5;n_6]);
    (n_5,  [n_6;n_3;n_7]);
    (n_6,  [n_8]);
    (n_7,  [n_6]);
    (n_8,  [n_7]);
]

(* dijsktra *)
let s_adjlist = [
    (s_a, [(s_s, 7.); (s_b, 3.); (s_d, 4.)]);
    (s_s, [(s_b, 2.); (s_c, 3.)]);
    (s_c, [(s_l, 2.)]);
    (s_l, [(s_i, 4.); (s_j, 4.)]);
    (s_i, [(s_j, 6.); (s_k, 4.)]);
    (s_j, [(s_k, 4.)]);
    (s_k, [(s_e, 5.)]);
    (s_d, [(s_b, 4.); (s_f, 5.)]);
    (s_f, [(s_h, 3.)]);
    (s_h, [(s_b, 1.); (s_g, 2.)]);
    (s_g, [(s_e, 2.)]);
];;

(* bellman ford *)
let t_adjlist = [
    (s_a, [(s_d,  40.);  (s_b, 5.); (s_c, 35.)]);
    (s_b, [(s_e,  25.);  (s_d, 20.)]);
    (s_c, [(s_e, -30.);  (s_f, 30.)]);
    (s_d, [(s_f,  20.);]);
    (s_e, [(s_f,  25.);  (s_d, 45.)]);
    (s_f, [(s_a,  -1.)]);
]

(* euler circuit *)
let t2_adjlist = [
    (s_a, [(s_b,  40.);  (s_c, 5.)]);
    (s_b, [(s_c,  25.);  (s_d, 20.)]);
    (* create negative cycle with this edge
    (s_c, [(s_d,  -10.);  (s_e, 30.)]);
    *)
    (s_c, [(s_d,  10.);  (s_e, 30.)]);
    (s_d, [(s_e,  20.);  (s_f, 0.)]);
    (s_e, [(s_f,  25.);  (s_a, 45.)]);
    (s_f, [(s_a,  -1.);  (s_b, 0.)]);
]

(* euler path *)
let q_adjlist = [
    (s_a, [(s_b, 0.);(s_c, 0.)]);
    (s_b, [(s_d, 0.)]);
    (s_c, [(s_a, 0.);(s_b, 0.);(s_e, 0.)]);
    (s_d, [(s_c, 0.);(s_f, 0.)]);
    (s_e, [(s_f, 0.)]);
    (s_f, [(s_c, 0.)]);
]

(* euler path - simpler DAG graph *)
let q2_adjlist = [
    (s_a, [(s_b, 0.);]);
    (s_b, [(s_d, 0.);(s_c, 0.)]);
    (s_c, [(s_b, 0.);]);
    (s_d, [(s_e, 0.);]);
    (s_e, [(s_f, 0.)]);
    (s_f, []);
]

let n_adjlist = [
    (n_0, [n_2]);
    (n_2, [n_1]);
    (n_1, [n_3;]);
    (n_3, [n_4; n_0]);
    (*(n_4, [n_6]);*)
    (n_6, [n_3; n_7]);
    (n_7, [n_8]);
    (n_8, [n_9]);
    (n_9, [n_6]);
]

let topo = [
    (s_a, []);
    (s_b, []);
    (s_c, [(s_d, 1.);]);
    (s_d, [(s_a, 1.);]);
    (s_e, [(s_a, 1.); (s_b, 1.)]);
    (s_f, [(s_a, 1.); (s_c, 1.)]);
]

(* Floyd warshall weighted *)
let fl_adjlist = [
    (n_1, [(n_2, 3.); (n_4, 7.)]);
    (n_2, [(n_1, 8.); (n_3, 2.)]);
    (n_3, [(n_1, 5.); (n_4, 1.)]);
    (n_4, [(n_1, 2.)]);
]

let floydwarshall graph = 
    let dist, map = SGraph.wgtmatrix (fun x -> `Val x) `Inf graph in
    let sz = List.length map in
    let karr = Array.init sz (fun _k -> 
        Array.init_matrix sz sz (fun i j -> 
            (* set the diagonals to 0 if they do not exist i.e `Inf *)
            let diag = dist.(i).(j) in
            if i = j && Graph.wcompare (Float.compare) diag `Inf = 0 then
                `Val Float.zero
            else
                diag
        )
    ) in
    let idx = sz - 1 in

    let _ = Format.printf "=================+============================================================\n" in
    let _ = Format.printf " (k) (i) (j)\t | \t ij\t\t ik\t\t kj\t\tik_kj\t\n=================+============================================================\n" in
    let _ =
        (for k = 1 to idx do 
            let k' = k - 1 in
            for i = 0 to idx do 
                if i = k' then () else
                    for j = 0 to idx do 
                        if j = k' || i = j then () else
                            let ij    = karr.(k').(i).(j) in
                            let ik    = karr.(k').(i).(k') in
                            let kj    = karr.(k').(k').(j) in
                            let ik_kj = Graph.wbind (Float.add) ik kj in

                            let _ = Format.printf "  %d   %d   %d\t |  \t%s\t\t%s\t\t%s\t\t%s\t\n" 
                                (k) (i+1) (j+1)
                                (Graph.string_of_wrap (Float.to_string) ij)
                                (Graph.string_of_wrap (Float.to_string) ik)
                                (Graph.string_of_wrap (Float.to_string) kj)
                                (Graph.string_of_wrap (Float.to_string) ik_kj)
                            in

                            if Graph.wcompare (Float.compare) ik_kj ij = -1 then
                                karr.(k).(i).(j) <- ik_kj
                    done
            done
        done) in
    let _ = Format.printf "=================+============================================================\n" in
    karr
;;

let heuristics = Hashtbl.create (SGraph.cardinal s);;

module Ser = struct 
    let string_of_elt = Fun.id
    let string_of_wgt = (Float.to_string)
    let elt_of_string = Fun.id
    let wgt_of_string = Float.of_string
end;;

module SGSer = SGraph.Serialize (Ser);;

(* global attributes *)
let gt   = SGSer.StyleTbl.create 1;;

(* node or edge attributes *)
let st'  = SGSer.StyleTbl.create 1;;
let st'' = SGSer.StyleTbl.create 1;;
let st3  = SGSer.StyleTbl.create 1;;

let est  = SGSer.StyleTbl.create 1;;

(* per node style attributes *)
let at   = SGSer.AttrbTbl.create 1;;

(* per edge style attributes *)
let et   = SGSer.AttrbTbl.create 1;;

SGSer.StyleTbl.add gt "rankdir" "LR";;

SGSer.StyleTbl.add st'  "color" "green";;
SGSer.StyleTbl.add st'' "color" "red";;
SGSer.StyleTbl.add st3  "color" "orange";;

SGSer.StyleTbl.add est  "style" "dashed";;

SGSer.AttrbTbl.add at s_s st' ;;
SGSer.AttrbTbl.add at s_b st3 ;;
SGSer.AttrbTbl.add at s_l st'';;

SGSer.AttrbTbl.add et (s_a^"-"^s_b) est;;

(* This heuristic table only works if the target is s_e!! *)
Hashtbl.add heuristics s_s 10.;;
Hashtbl.add heuristics s_a 9.;;
Hashtbl.add heuristics s_b 7.;;
Hashtbl.add heuristics s_c 8.;;
Hashtbl.add heuristics s_d 4.;;
Hashtbl.add heuristics s_e 0.;;
Hashtbl.add heuristics s_f 6.;;
Hashtbl.add heuristics s_g 3.;;
Hashtbl.add heuristics s_h 6.;;
Hashtbl.add heuristics s_i 4.;;
Hashtbl.add heuristics s_j 4.;;
Hashtbl.add heuristics s_k 3.;;
Hashtbl.add heuristics s_l 6.;;

let e_heuristic elt = `Val (Hashtbl.find heuristics elt);; 

let tarjanscc = SGraph.Scc.tarjan;;

let pp_sgraph (g: SGraph.adj SGraph.NodeMap.t) = 
    Format.printf "G: {\n"; 
    List.iter (fun (k, (_, v, _, w)) ->
        let _ = Format.printf "\t%s ->\t" k in 
        let _ = SGraph.AdjSet.iter (fun y ->
            try  Format.printf " (%s: %F)" y (SGraph.Vertex.edge2 y w)
            with 
                | Not_found -> 
                Format.printf " %s" y
        ) v in 
        Format.print_newline ()
    ) (SGraph.NodeMap.bindings g);
    Format.printf "} "
;;

let (let*) = Option.bind;;

let s  = SGraph.of_weights2 s_adjlist  s;;
let s' = SGraph.of_weights  s_adjlist  s';;
let t  = SGraph.of_weights  t_adjlist  t;;
let t' = SGraph.of_weights2 t2_adjlist t';;
let q  = SGraph.of_weights  q_adjlist  q;;
let q' = SGraph.of_weights  q2_adjlist q';;
let v  = SGraph.of_weights  topo       v;;
let n  = SGraph.of_list     n_adjlist  n;;
let scc = SGraph.of_list    scc_adjlist scc;;
let n' = SGraph.add_edge    n_4 n_6    n;;
let fl = SGraph.of_weights  fl_adjlist fl;;

(* balance the edges out for an eulerian path *)
let q  = SGraph.add_weight 0. s_b s_k @@ SGraph.add_weight 0. s_k s_d @@ SGraph.add s_k q;;

module SPath  = SGraph.Path.Compute(Graph.Biject(Float));;
module SPath2 = SGraph.Path.Compute(struct 
    include Float
    type t         = float
    type edge      = float
    let  compare   = Float.compare
    let  measure e = `Val e
end);;

let pp_pset (p: SPath.PathList.t SPath.PathSet.set) = 
    Format.printf "P: [\n"; 
    SPath.PathSet.iter (fun {from; next; via; value} ->
        Format.printf " (%s -> %s -> %s: %s)\n" from via next 
            (Graph.string_of_wrap (Float.to_string) value)
    ) p;
    Format.printf "] "
;;

let pp_aset (p: string SGraph.AdjSet.set) = 
    Format.printf "P: {"; 
    SGraph.AdjSet.iter (fun elt ->
        Format.printf " (%s) " elt
    ) p;
    Format.printf "} "
;;

#install_printer pp_pset;;
#install_printer pp_aset;;
#install_printer pp_sgraph;;

let a_s = SGraph.Path.mkpath s_a s_s `Inf ;;

let small l r = SGraph.Path.mkpath l r `Inf;;

let (uvis, init) = 
    (SGraph.outlist s)
    |>  List.fold_left (fun (kset, acc) (k, v) -> 
        (SGraph.AdjSet.add k kset, SGraph.AdjSet.fold (fun x a -> 
            SPath.PathHeap.insert (SGraph.Path.mkpath k x `Inf) a
        ) v acc)
    ) (SGraph.AdjSet.empty, SPath.PathHeap.empty) 
;;

let _ , init3 = SPath.PathHeap.extract init;;

module F  = Heap.MakeFibHeap (Heap.Surject(Int));;
let    f  = F.of_list [1;1;1;1;1;1;1;1;1;1;1;1;22;3;2];;
let d, f' = F.extract f;;

let timeonly f =
    let t = Unix.gettimeofday () in
    let _res = f () in
    Printf.printf "Execution time: %f secondsn" (Unix.gettimeofday () -. t)
;;

