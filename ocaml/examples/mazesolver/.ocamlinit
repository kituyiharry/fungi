#load "../../_build/default/examples/mazesolver/lib/mazesolver.cma";;
#load "../../_build/default/src/fungi.cma";;

open Fungi;;

module SGraph = Graph.MakeGraph(struct 
    type t     = string
    type edge  = float
    let compare= String.compare
end);;

module SGraph2 = Graph.MakeGraph(struct 
    type t     = string
    type edge  = unit
    let compare= String.compare
end);;
module SGraph4 = Graph.MakeGraph(Graph.Plain(String));;

let s = SGraph.empty;;

let s_a = "A";;
let s_b = "B";;
let s_c = "C";;
let s_d = "D";;
let s_e = "E";;
let s_f = "F";;
let s_g = "G";;
let s_h = "H";;
let s_i = "I";;
let s_j = "J";;
let s_k = "K";;
let s_l = "L";;
let s_s = "S";;

let nodes = [ s_a; s_b; s_c; s_d; s_e; s_f; s_g; s_h; s_i; s_j; s_k; s_l; s_s ];;

let s = List.fold_right (SGraph.add) nodes s;;

let _ = Printexc.record_backtrace true;;

let s_adjlist = [
    (s_a, [(s_s, 7.); (s_b, 3.); (s_d, 4.)]);
    (s_s, [(s_b, 2.); (s_c, 3.)]);
    (s_c, [(s_l, 2.)]);
    (s_l, [(s_i, 4.); (s_j, 4.)]);
    (s_i, [(s_j, 6.); (s_k, 4.)]);
    (s_j, [(s_k, 4.)]);
    (s_k, [(s_e, 5.)]);
    (s_d, [(s_b, 4.); (s_f, 5.)]);
    (s_f, [(s_h, 3.)]);
    (s_h, [(s_b, 1.); (s_g, 2.)]);
    (s_g, [(s_e, 2.)]);
];;

let heuristics = Hashtbl.create (SGraph.cardinal s);;
(* This heuristic table only works if the target is s_e!! *)
Hashtbl.add heuristics s_s 10.;;
Hashtbl.add heuristics s_a 9.;;
Hashtbl.add heuristics s_b 7.;;
Hashtbl.add heuristics s_c 8.;;
Hashtbl.add heuristics s_d 4.;;
Hashtbl.add heuristics s_e 0.;;
Hashtbl.add heuristics s_f 6.;;
Hashtbl.add heuristics s_g 3.;;
Hashtbl.add heuristics s_h 6.;;
Hashtbl.add heuristics s_i 4.;;
Hashtbl.add heuristics s_j 4.;;
Hashtbl.add heuristics s_k 3.;;
Hashtbl.add heuristics s_l 6.;;

let e_heuristic elt = `Value (Hashtbl.find heuristics elt);; 

let pp_sgraph (g: SGraph.adj SGraph.NodeMap.t) = 
    Format.printf "G: {\n"; 
    List.iter (fun (k, (_, v, _, _)) ->
        let _ = Format.printf "\t%s ->\t" k in 
        let _ = SGraph.AdjSet.iter (fun y ->
            Format.printf " %s " y
        ) v in 
        Format.print_newline ()
    ) (SGraph.NodeMap.bindings g);
  Format.printf "} "
;;

#install_printer pp_sgraph;;

let s = SGraph.of_weights2 s_adjlist s;;

module SPath  = SGraph.Path.Compute(Graph.Biject(Float));;
module SPath2 = SGraph.Path.Compute(struct 
        include Float
        type t         = float
        type edge      = float
        let  compare   = Float.compare
        let  measure e = `Value e
end);;

let a_s = SGraph.Path.mkpath s_a s_s `Inf ;;

let small l r = SGraph.Path.mkpath l r `Inf;;

let (uvis, init) = 
    (SGraph.outlist s)
    |>  List.fold_left (fun (kset, acc) (k, v) -> 
        (SGraph.AdjSet.add k kset, SGraph.AdjSet.fold (fun x a -> 
            SPath.PathHeap.insert (SGraph.Path.mkpath k x `Inf) a
        ) v acc)
    ) (SGraph.AdjSet.empty, SPath.PathHeap.empty) 
;;

let _ , init3 = SPath.PathHeap.extract init;;
let t = (SGraph.Path.mkpath s_d s_b `Inf);;

module F  = Heap.MakeFibHeap (Heap.Surject(Int));;
let    f  = F.of_list [1;1;1;1;1;1;1;1;1;1;1;1;22;3;2];;
let d, f' = F.extract f;;
