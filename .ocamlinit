(* Generated by `dune ocaml top` *)
#load "./_build/default/libparity.cma";;

open Libparity;;
open Libparity.Paritygame;;
open Libparity.Myset;;
open Libparity.Utils;;

let p = ParityGame.empty;;

(* I also assume there are no same priority nodes to make life easy *)
let (l_2, p)  = ParityGame.add_node  ParityGame.Even 2  p;;
let (l_15,p)  = ParityGame.add_node  ParityGame.Odd  15 p;;
let (l_4, p)  = ParityGame.add_node  ParityGame.Even 4  p;;
let (l_6, p)  = ParityGame.add_node  ParityGame.Even 6  p;;
let (l_8, p)  = ParityGame.add_node  ParityGame.Even 8  p;;
let (l_10,p)  = ParityGame.add_node  ParityGame.Even 10 p;;
let (l_3, p)  = ParityGame.add_node  ParityGame.Odd  3  p;;
let (l_5, p)  = ParityGame.add_node  ParityGame.Odd  5  p;;
let (l_7, p)  = ParityGame.add_node  ParityGame.Odd  7  p;;
let (l_9, p)  = ParityGame.add_node  ParityGame.Odd  9  p;;
let (l_11,p)  = ParityGame.add_node  ParityGame.Odd  11 p;;
let (l_13,p)  = ParityGame.add_node  ParityGame.Odd  13 p;;

(** Effect of opposer-controlled but supportive priority *)

(*let (l_16,p)  = ParityGame.add_node  ParityGame.Odd  16 p;;*)
(*let (l_31,p)  = ParityGame.add_node  ParityGame.Even 31 p;;*)

(** Effect of  Disjointness  - Graph not being fully connected *)

(*let (l_99,p)  = ParityGame.add_node  ParityGame.Odd  9 p;;*)

(**
  A non-empty Parity game will always have a Even labeled node 2 or
  an Odd labeled node 3
**)

(**
parity 15;
2  2 0 4, 11 "2";
4  4 0 2, 8, 6 "4";
6  6 0 3, 5, 7, 9 "6";
8  8 0 7, 5, 2 "8";
10 10 0 13, 15 "10";
3  3 1 2, 4 "3";
5  5 1 5, 7, 9 "5";
7  7 1 10, 7 "7";
9  9 1 3, 10, 5 "9";
11 11 1 8 "11";
13 13 1 15 "13";
15 15 1 13 "15";

-- Ommited for testing other stuff
16 16 1 2,31 "16";
31 31 0 15,16 "31";
99 99 1 99 "99";

 *)

let p_adjlist =
  [
    (l_2,  [l_4;  l_11]);
    (l_4,  [l_2;  l_8;  l_6]);
    (l_6,  [l_3;  l_5;  l_7; l_9]);
    (l_8,  [l_7;  l_5;  l_2]);
    (l_10, [l_13; l_15]);
    (l_3,  [l_2;  l_4]);
    (l_5,  [l_7;  l_9]);
    (l_7,  [l_10]);
    (l_9,  [l_3;  l_5;  l_10]);
    (l_11, [l_8]);
    (l_13, [l_15]);
    (l_15, [l_13])
]

let p = ParityGame.Graph.of_list p_adjlist p;;

(** Effect of opposer-controlled but supportive priority *)

(*let p = ParityGame.Graph.add_edge l_16 l_2   p;;*)
(*let p = ParityGame.Graph.add_edge l_2 l_16   p;;*)
(*let p = ParityGame.Graph.add_edge l_15 l_31  p;;*)
(*let p = ParityGame.Graph.add_edge l_31 l_15  p;;*)
(*let p = ParityGame.Graph.add_edge l_31 l_16  p;;*)
(*let p = ParityGame.Graph.add_edge l_16 l_31  p;;*)

(** Leading into the highest value of the opposition *)
(*let p = ParityGame.add_edge l_11 l_31  p;;*)

(** Effect of  Disjointness *)

(*let p = ParityGame.add_edge l_99 l_99  p;;*)


(**

parity 10;
0 6 0 2,3,5 "0";
1 10 0 3,4,8 "1";
2 6 1 0,5,7 "2";
3 2 0 0,3,9 "3";
4 7 0 2,5,7 "4";
5 0 0 0,4,8 "5";
6 7 0 0,5,8 "6";
7 9 0 1,3,9 "7";
8 9 0 4,6,9 "8";
9 2 0 2,4,8 "9";

 *)

let q =  ParityGame.empty

let (q_0, q)  = ParityGame.add_node   ParityGame.Even 6  q;;
let (q_1, q)  = ParityGame.add_node   ParityGame.Even 10 q;;
let (q_2, q)  = ParityGame.add_node   ParityGame.Odd  6  q;;
let (q_3, q)  = ParityGame.add_node   ParityGame.Even 2  q;;
let (q_4, q)  = ParityGame.add_node   ParityGame.Even 7  q;;
let (q_5, q)  = ParityGame.add_node   ParityGame.Even 0  q;;
let (q_6, q)  = ParityGame.add_node   ParityGame.Even 7  q;;
let (q_7, q)  = ParityGame.add_node   ParityGame.Even 9  q;;
let (q_8, q)  = ParityGame.add_node   ParityGame.Even 9  q;;
let (q_9, q)  = ParityGame.add_node   ParityGame.Even 2  q;;

let q_adjlist =
  [
    (q_0, [q_2; q_3; q_5;]);
    (q_1, [q_3; q_4; q_8;]);
    (q_2, [q_0; q_5; q_7;]);
    (q_3, [q_0; q_3; q_9;]);
    (q_4, [q_2; q_5; q_7;]);
    (q_5, [q_0; q_4; q_8;]);
    (q_6, [q_0; q_5; q_8;]);
    (q_7, [q_1; q_3; q_9;]);
    (q_8, [q_4; q_6; q_9;]);
    (q_9, [q_2; q_4; q_8;])
  ]

let q = ParityGame.Graph.of_list q_adjlist q;;

let r = ParityGame.empty

let (r_100, r)  = ParityGame.add_node ParityGame.Even 100 r;;
let (r_5, r)    = ParityGame.add_node ParityGame.Even 5   r;;
let (r_1, r)    = ParityGame.add_node ParityGame.Even 1   r;;
let (r_0, r)    = ParityGame.add_node ParityGame.Even 0   r;;
let (r_0_b, r)  = ParityGame.add_node ParityGame.Even 0   r;;
let (r_0_c, r)  = ParityGame.add_node ParityGame.Even 0   r;;

let r_adjlist =
  [
    (r_1,   [r_0;]);
    (r_0,   [r_5;]);
    (r_5,   [r_0_b;]);
    (r_0_b, [r_1;]);
    (r_100, [r_0_b; r_0_c]);
    (r_0_c, [r_0_c]);
  ]

let r = ParityGame.Graph.of_list r_adjlist r;;

(* Convenience functions for printing in the REPl *)
(** [asplayerprio ParityGame.t (node * priority)]
helper to show parity game as a graph without the random generated ids *)
let asplayerprio (ParityGame.Label (ParityGame.Priority (value, player) as prio , _rand)) =
    (player, prio)
;;

let print_player_prio (ParityGame.Label(ParityGame.Priority (value,pplayer),_))  = match pplayer with
| ParityGame.Even -> Format.printf " (Even %d) " value
| ParityGame.Odd  -> Format.printf " (Odd %d) " value
;;

let print_player_prio_dir (_, (ParityGame.Priority (value,pplayer)))  = match pplayer with
| ParityGame.Even -> Format.printf " (Even %d) " value
| ParityGame.Odd  -> Format.printf " (Odd %d) " value
;;

let pp_parity_game:(ParityGame.AdjSet.t * ParityGame.AdjSet.t * ParityGame.node) ParityGame.Nodes.t -> unit = fun game ->
  Format.printf "G: {";
   List.iter (print_player_prio)
   (
    ParityGame.bindings game
   );
  Format.printf "} "
;;

let pp_adjset_depth (set: ParityGame.AdjSet.t) =
  Format.printf "{$ A: {";
  if ParityGame.AdjSet.is_empty set then
    Format.printf " ∅ "
      else
  List.iter (print_player_prio_dir)
  (
    List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
  );
    Format.printf "} $} "
;;

let pp_adjset set =
  Format.printf "{$ A: {";
  if ParityGame.AdjSet.is_empty set then
  Format.printf " ∅ "
      else
  List.iter (print_player_prio_dir)
  (
    List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
  );
    Format.printf "} $} "
;;

let terseness = 30

let pp_parity_game_terse:(ParityGame.AdjSet.t * ParityGame.AdjSet.t *
    ParityGame.node) ParityGame.Nodes.t -> unit =
  fun game ->
  let card = ParityGame.Nodes.cardinal game in
  if  card <= terseness then
    pp_parity_game game
  else
    (Format.printf "G: {";
    List.iter (print_player_prio)
    (
      Utils.take terseness
      @@ ParityGame.bindings game
    );
    Format.printf " ... } ")
;;

let pp_adjset_terse set =
  let card = ParityGame.AdjSet.cardinal set in
  if  card <= terseness then
    pp_adjset set
  else
    let _ = Format.printf "A: {" in
    if ParityGame.AdjSet.is_empty set then
      Format.printf " ∅ "
    else
      let _ = List.iter (print_player_prio_dir)
    (
      (*only take 5 elements for display!*)
      Utils.take terseness @@ List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
    ) in Format.printf " ... } "
;;

let pp_prio (ParityGame.Priority (value, pplayer)) = match pplayer with
  | ParityGame.Even -> Format.printf " (Even %d) " value
  | ParityGame.Odd  -> Format.printf " (Odd  %d) " value
;;

let pp_node (ParityGame.Label (prio, rand )) =
    let () =    Format.printf "%d:" rand in
        pp_prio prio
;;

let pp_player_adjlist: (ParityGame.node * ParityGame.node list) -> unit =
  fun  (n, a)->
    let () = pp_node n in
    let () = Format.printf "\t-> [" in
    let () = List.iter (pp_node) a in
    Format.printf "]\n"
;;


let pp_parity_game_adjacency:(ParityGame.AdjSet.t * ParityGame.AdjSet.t * ParityGame.node) ParityGame.Nodes.t -> unit
= fun game ->
  Format.printf "{\n";
   List.iter (pp_player_adjlist)
   (
     List.map (fun node -> (node, ParityGame.Graph.adj_list_of node game))
     @@ ParityGame.bindings game
   );
  Format.printf "} "
;;

let pp_adjset_prefix set prefix =
  Format.printf "%s: {" prefix;
  if ParityGame.AdjSet.is_empty set then
  Format.printf " ∅ "
      else
  List.iter (print_player_prio_dir)
  (
    List.map (asplayerprio) @@ ParityGame.AdjSet.elements set
  );
  Format.printf "} "
;;

let pp_player_inc_out: (ParityGame.node * ParityGame.AdjSet.t * ParityGame.AdjSet.t) -> unit =
  fun  (n, i, o)->
    let () = Format.printf "    " in
    let () = pp_node n in
    let () = Format.printf "\t-> [" in
    let () = pp_adjset_prefix i "In" in
    let () = pp_adjset_prefix o "Out" in
    Format.printf "]\n"
;;

let pp_parity_game_redundant:(ParityGame.AdjSet.t * ParityGame.AdjSet.t *
    ParityGame.node) ParityGame.Nodes.t -> unit
= fun game ->
  Format.printf "{\n";
   List.iter (pp_player_inc_out)
   (
     List.map (fun (node) -> (node, ParityGame.Graph.incomingof node game,
                ParityGame.Graph.outgoingof node game ))
     @@ ParityGame.bindings game
   );
  Format.printf "} "
;;

let ppluck fromset =
  match ParityGame.StrSet.max_elt_opt fromset with
  | Some(node) -> Some (node, (ParityGame.StrSet.remove node fromset))
  | _ -> None
;;

let rec pp_strat: ParityGame.StrSet.t ->  unit = fun strat ->
  if ParityGame.StrSet.is_empty strat then
    Format.printf " ∅ "
  else
    match ppluck strat with
    | None -> ()
    | Some(((f, t), rest)) -> (
      pp_node f; Format.printf " -> "; pp_node t; Format.printf ",";
      pp_strat rest
    );
;;

let pp_solution:(ParityGame.solution) -> unit = fun sol ->
 let ((w0, w1), (s0, s1)) = (sol.regions, sol.strategy) in
  Format.printf "\n\t+ ---  ---  --- --- --- --- --- --- --- --- --- --- ---";
  Format.printf "\n\t|\n\t| W0: ";  pp_adjset w0;
  Format.printf "\n\t| S0:    <";  pp_strat s0; Format.printf ">";
  Format.printf "\n\t|\n\t| ---  ---  --- --- --- --- --- --- --- --- --- --- ---";
  Format.printf "\n\t|\n\t| W1: ";  pp_adjset w1;
  Format.printf "\n\t| S1:    <";  pp_strat s1; Format.printf ">";
  Format.printf "\n\t|\n\t+ ---  ---  --- --- --- --- --- --- --- --- --- --- ---"
;;

(*#install_printer pp_parity_game;;*)
(*#install_printer pp_parity_game_redundant;;*)
(*#install_printer pp_adjset;;*)
(*#install_printer pp_prio;;*)
(*#install_printer pp_node;;*)
(*#install_printer pp_strat;;*)
#install_printer pp_solution;;
(*#install_printer pp_adjset_depth;;*)

(*#trace ParityGame.zielonka;;*)
(*#trace ParityGame.attr;;*)
(*#trace ParityGame.attractor;;*)
(*#trace ParityGame.attract;;*)
(*#trace ParityGame.attractive;;*)
(*#trace ParityGame.cluster;;*)
(*#trace ParityGame.pluck;;*)
(*#trace ParityGame.incomingof;;*)
(*#trace ParityGame.outgoingof;;*)
(*#trace ParityGame.carve;;*)
(*#trace ParityGame.AdjSet.remove;;*)
(*#trace ParityGame.AdjSet.diff;;*)
(*#trace ParityGame.AdjSet.filter;;*)
(*#trace ParityGame.AdjSet.subset;;*)
(*#trace ParityGame.stack;;*)
(*#trace ParityGame.StrSet.of_list;;*)
(*#trace ParityGame.cmpplays;;*)
