(* Generated by `dune ocaml top` *)
#load "./_build/default/libset.cma";;

open Libset;;
open Libset.Paritygame;;
open Libset.Myset;;
open Libset.Utils;;

let p = PGame.empty;;

(* I also assume there are no same priority nodes to make life easy *)
let (l_2, p)  = PGame.add_node  PGame.Even 2  p;;
let (l_4, p)  = PGame.add_node  PGame.Even 4  p;;
let (l_6, p)  = PGame.add_node  PGame.Even 6  p;;
let (l_8, p)  = PGame.add_node  PGame.Even 8  p;;
let (l_10,p)  = PGame.add_node  PGame.Even 10 p;;
let (l_3, p)  = PGame.add_node  PGame.Odd  3  p;;
let (l_5, p)  = PGame.add_node  PGame.Odd  5  p;;
let (l_7, p)  = PGame.add_node  PGame.Odd  7  p;;
let (l_9, p)  = PGame.add_node  PGame.Odd  9  p;;
let (l_11,p)  = PGame.add_node  PGame.Odd  11 p;;
let (l_13,p)  = PGame.add_node  PGame.Odd  13 p;;
let (l_15,p)  = PGame.add_node  PGame.Odd  15 p;;

(** Effect of opposer-controlled but supportive priority *)

(*let (l_16,p)  = PGame.add_node  PGame.Odd  16 p;;*)
(*let (l_31,p)  = PGame.add_node  PGame.Even 31 p;;*)

(** Effect of  Disjointness  - Graph not being fully connected *)

(*let (l_99,p)  = PGame.add_node  PGame.Odd  9 p;;*)

(**
  A non-empty Parity game will always have a Even labeled node 2 or
  an Odd labeled node 3
**)

(**
parity 15;
2  2 0 4, 11 "2";
4  4 0 2, 8, 6 "4";
6  6 0 3, 5, 7, 9 "6";
8  8 0 7, 5, 2 "8";
10 10 0 13, 15 "10";
3  3 1 2, 4 "3";
5  5 1 5, 7, 9 "5";
7  7 1 10, 7 "7";
9  9 1 3, 10, 5 "9";
11 11 1 8 "11";
13 13 1 15 "13";
15 15 1 13 "15";

-- Ommited for testing other stuff
16 16 1 2,31 "16";
31 31 0 15,16 "31";
99 99 1 99 "99";

 *)

let p_adjlist =
  [
    (l_2,  [l_4;  l_11]);
    (l_4,  [l_2;  l_8;  l_6]);
    (l_6,  [l_3;  l_5;  l_7; l_9]);
    (l_8,  [l_7;  l_5;  l_2]);
    (l_10, [l_13; l_15]);
    (l_3,  [l_2;  l_4]);
    (l_5,  [l_7;  l_9]);
    (l_7,  [l_10]);
    (l_9,  [l_3;  l_5;  l_10]);
    (l_11, [l_8]);
    (l_13, [l_15]);
    (l_15, [l_13])
]

let p = PGame.use_adjlist_desc p_adjlist p;;

(** Effect of opposer-controlled but supportive priority *)

(*let p = PGame.add_edge l_16 l_2   p;;*)
(*let p = PGame.add_edge l_2 l_16   p;;*)
(*let p = PGame.add_edge l_15 l_31  p;;*)
(*let p = PGame.add_edge l_31 l_15  p;;*)
(*let p = PGame.add_edge l_31 l_16  p;;*)
(*let p = PGame.add_edge l_16 l_31  p;;*)

(** Leading into the highest value of the opposition *)
(*let p = PGame.add_edge l_11 l_31  p;;*)

(** Effect of  Disjointness *)

(*let p = PGame.add_edge l_99 l_99  p;;*)


(**

parity 10;
0 6 0 2,3,5 "0";
1 10 0 3,4,8 "1";
2 6 1 0,5,7 "2";
3 2 0 0,3,9 "3";
4 7 0 2,5,7 "4";
5 0 0 0,4,8 "5";
6 7 0 0,5,8 "6";
7 9 0 1,3,9 "7";
8 9 0 4,6,9 "8";
9 2 0 2,4,8 "9";

 *)

let q =  PGame.empty

let (q_0, q)  = PGame.add_node   PGame.Even 6  q;;
let (q_1, q)  = PGame.add_node   PGame.Even 10 q;;
let (q_2, q)  = PGame.add_node   PGame.Odd  6  q;;
let (q_3, q)  = PGame.add_node   PGame.Even 2  q;;
let (q_4, q)  = PGame.add_node   PGame.Even 7  q;;
let (q_5, q)  = PGame.add_node   PGame.Even 0  q;;
let (q_6, q)  = PGame.add_node   PGame.Even 7  q;;
let (q_7, q)  = PGame.add_node   PGame.Even 9  q;;
let (q_8, q)  = PGame.add_node   PGame.Even 9  q;;
let (q_9, q)  = PGame.add_node   PGame.Even 2  q;;

let q_adjlist =
  [
    (q_0, [q_2; q_3; q_5;]);
    (q_1, [q_3; q_4; q_8;]);
    (q_2, [q_0; q_5; q_7;]);
    (q_3, [q_0; q_3; q_9;]);
    (q_4, [q_2; q_5; q_7;]);
    (q_5, [q_0; q_4; q_8;]);
    (q_6, [q_0; q_5; q_8;]);
    (q_7, [q_1; q_3; q_9;]);
    (q_8, [q_4; q_6; q_9;]);
    (q_9, [q_2; q_4; q_8;])
  ]

let q = PGame.use_adjlist_desc q_adjlist q;;

let r = PGame.empty

let (r_100, r)  = PGame.add_node   PGame.Even 100 r;;
let (r_5, r)  = PGame.add_node   PGame.Even 5   r;;
let (r_1, r)  = PGame.add_node   PGame.Even 1   r;;
let (r_0, r)  = PGame.add_node   PGame.Even 0   r;;

let r_adjlist =
  [
    (r_0,   [r_0;]);
    (r_100, [r_0;]);
    (r_5,   [r_100; r_1]);
    (r_1,   [r_5;])
  ]

let r = PGame.use_adjlist_desc r_adjlist r;;

(* Convenience functions for printing in the REPl *)
(** [asplayerprio PGame.t (identity * priority)]
helper to show parity game as a graph without the random generated ids *)
let asplayerprio (PGame.Label (PGame.Priority (value, player) as prio , _rand)) =
    (player, prio)
;;

let print_player_prio (_, (PGame.Priority (value, pplayer)))  = match pplayer with
| PGame.Even -> Format.printf " (Even %d) " value
| PGame.Odd  -> Format.printf " (Odd %d) " value
;;

let pp_parity_game:(PGame.AdjSet.t * PGame.AdjSet.t * PGame.priority) PGame.Nodes.t -> unit = fun game ->
  Format.printf "G: {";
   List.iter (print_player_prio)
   (
    PGame.Graph.elt_bindings game
   );
  Format.printf "} "
;;

let pp_adjset set =
  Format.printf "A: {";
  if PGame.AdjSet.is_empty set then
  Format.printf " ∅ "
      else
  List.iter (print_player_prio)
  (
    List.map (asplayerprio) @@ PGame.AdjSet.elements set
  );
  Format.printf "} "
;;

let terseness = 30

let pp_parity_game_terse:(PGame.AdjSet.t * PGame.AdjSet.t * PGame.priority) PGame.Nodes.t -> unit =
  fun game ->
  let card = PGame.Nodes.cardinal game in
  if  card <= terseness then
    pp_parity_game game
  else
    (Format.printf "G: {";
    List.iter (print_player_prio)
    (
      Utils.take terseness
      @@ PGame.Graph.elt_bindings game
    );
    Format.printf " ... } ")
;;

let pp_adjset_terse set =
  let card = PGame.AdjSet.cardinal set in
  if  card <= terseness then
    pp_adjset set
  else
    let _ = Format.printf "A: {" in
    if PGame.AdjSet.is_empty set then
      Format.printf " ∅ "
    else
      let _ = List.iter (print_player_prio)
    (
      (*only take 5 elements for display!*)
      Utils.take terseness @@ List.map (asplayerprio) @@ PGame.AdjSet.elements set
    ) in Format.printf " ... } "
;;

let pp_prio (PGame.Priority (value, pplayer)) = match pplayer with
  | PGame.Even -> Format.printf " (Even %d) " value
  | PGame.Odd  -> Format.printf " (Odd  %d) " value
;;

let pp_node (PGame.Label (prio, _rand )) =
  pp_prio prio
;;

let pp_player_adjlist: (PGame.identity * PGame.identity list) -> unit =
  fun  (n, a)->
    let () = pp_node n in
    let () = Format.printf "\t-> [" in
    let () = List.iter (pp_node) a in
    Format.printf "]\n"
;;


let pp_parity_game_adjacency:(PGame.AdjSet.t * PGame.AdjSet.t * PGame.priority) PGame.Nodes.t -> unit
= fun game ->
  Format.printf "{\n";
   List.iter (pp_player_adjlist)
   (
     List.map (fun (node, _) -> (node, PGame.Graph.adj_list_of node game))
     @@ PGame.Graph.elt_bindings game
   );
  Format.printf "} "
;;

let pp_adjset_prefix set prefix =
  Format.printf "%s: {" prefix;
  if PGame.AdjSet.is_empty set then
  Format.printf " ∅ "
      else
  List.iter (print_player_prio)
  (
    List.map (asplayerprio) @@ PGame.AdjSet.elements set
  );
  Format.printf "} "
;;

let pp_player_inc_out: (PGame.identity * PGame.AdjSet.t * PGame.AdjSet.t) -> unit =
  fun  (n, i, o)->
    let () = Format.printf "    " in
    let () = pp_node n in
    let () = Format.printf "\t-> [" in
    let () = pp_adjset_prefix i "In" in
    let () = pp_adjset_prefix o "Out" in
    Format.printf "]\n"
;;

let pp_parity_game_redundant:(PGame.AdjSet.t * PGame.AdjSet.t * PGame.priority) PGame.Nodes.t -> unit
= fun game ->
  Format.printf "{\n";
   List.iter (pp_player_inc_out)
   (
     List.map (fun (node, _) -> (node, PGame.incomingof node game, PGame.outgoingof node game ))
     @@ PGame.Graph.elt_bindings game
   );
  Format.printf "} "
;;

let ppluck fromset =
  match PGame.Strat.max_elt_opt fromset with
  | Some(node) -> Some (node, (PGame.Strat.remove node fromset))
  | _ -> None
;;

let rec pp_strat: PGame.Strat.t ->  unit = fun strat ->
  match ppluck strat with
  | None -> ()
  | Some(((f, t), rest)) -> (
    pp_node f; Format.printf " -> "; pp_node t; Format.printf ",";
    pp_strat rest
  );
;;

let pp_solution:(PGame.solution) -> unit = fun sol ->
 let ((w0, w1), (s0, s1)) = (sol.regions, sol.strategy) in
  Format.printf "\n\t+ ---  ---  --- --- --- --- --- --- --- --- --- --- ---";
  Format.printf "\n\t|\n\t| W0: ";  pp_adjset w0;
  Format.printf "\n\t| S0:   < ";  pp_strat s0; Format.printf ">";
  Format.printf "\n\t|\n\t| ---  ---  --- --- --- --- --- --- --- --- --- --- ---";
  Format.printf "\n\t|\n\t| W1: ";  pp_adjset w1;
  Format.printf "\n\t| S1:   < ";  pp_strat s1; Format.printf ">";
  Format.printf "\n\t|\n\t+ ---  ---  --- --- --- --- --- --- --- --- --- --- ---"
;;

(*#install_printer pp_parity_game;;*)
#install_printer pp_parity_game_redundant;;
#install_printer pp_adjset;;
#install_printer pp_prio;;
#install_printer pp_node;;
#install_printer pp_strat;;
#install_printer pp_solution;;

(*#trace PGame.zielonka;;*)
(*#trace PGame.stack;;*)
(*#trace PGame.Strat.of_list;;*)
(*#trace PGame.cmpplays;;*)
